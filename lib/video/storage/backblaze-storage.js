// lib/video/storage/backblaze-storage.js

import { StorageProvider, UploadResult, UploadConfig } from './storage-interface'

/**
 * Backblaze B2 Storage Provider
 * Uses S3-compatible API for Backblaze B2
 */
export class BackblazeB2Storage extends StorageProvider {
  constructor(config) {
    super(config)
    this.bucketName = config.bucketName || process.env.BACKBLAZE_BUCKET_NAME
    this.endpoint = config.endpoint || process.env.BACKBLAZE_ENDPOINT
    this.keyId = config.keyId || process.env.BACKBLAZE_KEY_ID
    this.applicationKey = config.applicationKey || process.env.BACKBLAZE_APPLICATION_KEY
    this.publicUrl = `https://${this.bucketName}.${this.endpoint}`
  }

  async initialize() {
    // Validate configuration
    if (!this.bucketName || !this.endpoint || !this.keyId || !this.applicationKey) {
      throw new Error('Backblaze B2 configuration incomplete')
    }
  }

  /**
   * Get presigned POST data for direct browser upload
   * This should be called from a server action/API route
   * @param {Object} params - Upload parameters
   * @returns {Promise<UploadConfig>} Upload configuration
   */
  async getUploadConfig(params) {
    const { fileName, contentType, contentLength, metadata = {} } = params
    
    // Generate a unique key for the file
    const timestamp = Date.now()
    const sanitizedFileName = fileName.replace(/[^a-zA-Z0-9.-]/g, '_')
    const key = `videos/${timestamp}-${sanitizedFileName}`
    
    // This data structure is what you'll need to generate on the server
    // using AWS SDK v3 with S3 client configured for B2
    const uploadConfig = {
      url: `https://${this.endpoint}/${this.bucketName}`,
      method: 'PUT',
      headers: {
        'Content-Type': contentType,
        'Cache-Control': 'public, max-age=31536000',
      },
      // These will be generated by the server-side presigned POST
      // We'll create the server action next
      presignedData: null
    }

    return new UploadConfig({
      url: uploadConfig.url,
      method: uploadConfig.method,
      headers: uploadConfig.headers,
      fields: { key }, // Store key for reference
      maxSize: 2 * 1024 * 1024 * 1024, // 2GB
      publicUrl: `${this.publicUrl}/${key}`
    })
  }

  /**
   * Get the public URL for a file
   * @param {string} path - File path
   * @returns {string} Public URL
   */
  getPublicUrl(path) {
    return `${this.publicUrl}/${path}`
  }

  /**
   * Parse B2 response and create upload result
   * @param {Object} response - B2 response
   * @param {Object} uploadConfig - Upload configuration used
   * @returns {UploadResult} Standardized upload result
   */
  parseUploadResponse(response, uploadConfig) {
    return new UploadResult({
      url: uploadConfig.publicUrl,
      path: uploadConfig.fields.key,
      size: uploadConfig.headers['Content-Length'] || 0,
      contentType: uploadConfig.headers['Content-Type'],
      provider: 'backblaze-b2',
      metadata: {
        bucket: this.bucketName,
        endpoint: this.endpoint
      }
    })
  }

  // These methods would be implemented for server-side operations
  // For direct browser uploads, they're not used
  async upload(file, path, options = {}) {
    throw new Error('Use getUploadConfig() for direct browser uploads')
  }

  async delete(path) {
    // This would need server-side implementation
    throw new Error('Delete operations must be performed server-side')
  }

  async getSignedUrl(path, expiresIn = 3600) {
    // This would need server-side implementation
    throw new Error('Signed URL generation must be performed server-side')
  }

  async exists(path) {
    // This would need server-side implementation
    throw new Error('Existence checks must be performed server-side')
  }

  async getMetadata(path) {
    // This would need server-side implementation
    throw new Error('Metadata retrieval must be performed server-side')
  }

  async list(prefix, options = {}) {
    // This would need server-side implementation
    throw new Error('Listing must be performed server-side')
  }
}

/**
 * Helper function to upload directly to B2 from browser using PUT
 * @param {File} file - File to upload
 * @param {Object} uploadData - Upload data from server (with presigned URL)
 * @param {Function} onProgress - Progress callback
 * @returns {Promise<Object>} Upload result
 */
export async function uploadToB2(file, uploadData, onProgress) {
  // Use XMLHttpRequest for progress tracking
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest()
    
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable && onProgress) {
        const percentComplete = (e.loaded / e.total) * 100
        onProgress(percentComplete)
      }
    })
    
    xhr.addEventListener('load', () => {
      if (xhr.status === 200 || xhr.status === 201 || xhr.status === 204) {
        resolve({
          success: true,
          url: uploadData.publicUrl
        })
      } else {
        console.error('Upload failed with status:', xhr.status, xhr.responseText)
        reject(new Error(`Upload failed with status ${xhr.status}`))
      }
    })
    
    xhr.addEventListener('error', () => {
      console.error('Upload error:', xhr.statusText)
      reject(new Error('Upload failed'))
    })
    
    // Use PUT method with the presigned URL
    xhr.open(uploadData.method || 'PUT', uploadData.url)
    
    // Set headers if provided
    if (uploadData.headers) {
      Object.entries(uploadData.headers).forEach(([key, value]) => {
        // Skip Content-Length header - browser sets it automatically
        if (key.toLowerCase() !== 'content-length') {
          xhr.setRequestHeader(key, value)
        }
      })
    }
    
    // Send the file directly (not as FormData for PUT)
    xhr.send(file)
  })
}